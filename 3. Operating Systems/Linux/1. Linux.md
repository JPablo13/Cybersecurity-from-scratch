# Linux

GNU/Linux is the result of combining the Linux kernel, which is the core responsible for managing the hardware, with the tools and utilities of the GNU project, which provide essential functionalities for this operating system to be usable. For this reason, it is called GNU/Linux.
GNU/Linux distributions are complete operating systems based on the Linux kernel. They include GNU tools and other additional components, such as package managers, graphical environments, and specific applications. These customizations allow each distribution to be optimized for different niches or uses. These distributions include:
- **Debian**: Known for its stability and use on servers.
- **Slackware**: Aimed at advanced users looking for minimalist environments.
- **Arch Linux**: Focused on simplicity and customization.
- **Red Hat Enterprise Linux (RHEL)**: Aimed at business and server environments.
- **Ubuntu**: A Debian-based distribution.

## Linux Structure

The file system in Linux is a hierarchical structure that organizes system data and resources. It starts at the root, represented as **/**. From the root, several directories are deployed that house different types of data and configurations. These files can be contained in partitions, basically sections within the storage unit where the system is installed that are separated from each other, allowing for much more organized information.
Linux supports several file system formats, such as:
- EXT4 (Extended Filesystem 4): One of the most widely used due to its reliability and performance.
- XFS: Optimized for handling large volumes of data, especially ideal for business environments.
- BTRFS: Designed for snapshots, high scalability, and advanced features such as built-in compression.
The key elements of a file system are:
- Inodes: Stores metadata information (permissions, owner, size, etc.) about a file or directory.
- Blocks: These are storage units where file data is stored.
- Super Block: Contains crucial information about the file system. If the super block is damaged, the system can be difficult to recover.
In Linux, there are two types of links:
- Hard links: These are direct references to the same inode, meaning they point to the same file content. If the file is deleted, the content will remain accessible as long as the hard links exist.
- Soft or symbolic links: Point to the file path instead of the content. If the original file is deleted, the symbolic link is broken.

## What is a command?

A command is an instruction that the user enters through the terminal to have the system perform a specific task. Commands are interpreted by the shell, which translates these orders into actions that can be executed by the system. Each command can be associated with a set of predefined instructions that, when executed, allow the user to interact with the system and perform operations such as managing files, checking system information, or running programs.
## Shell vs. Terminal Emulator
A terminal is simply the software that provides the interface that allows data input and output within which a shell can be executed. In the past, the only way to give instructions to the operating system was through a terminal. However, things have changed now. Now, all commonly used operating systems have a graphical interface, making them more user-friendly, since the easier an operating system is, the more people can use it. Terminal emulators, on the other hand, basically emulate a physical terminal, within which a shell can be executed. A shell is a program whose primary function is to interpret commands. Through this command interpretation, it uses system resources to achieve the desired action. It could be said that the shell is a bridge between the user and the operating system, allowing commands to be given to the system. The most common are:
- sh: This is the basic shell, generally included in the vast majority of UNIX systems.
- bash: This is an improvement on sh, with additional features such as command history, autocompletion, and advanced scripting.
- zsh: This is a modern shell that combines features of bash and other shells such as ksh, with improvements in interactivity, advanced autocompletion, and plugins.
## Introduction to the prompt in Linux

It can be commonly referred to as the command prompt or the prompt that indicates we are in a shell within the terminal emulator. The basic structure of bash is as follows:
**user@host:path$**
- user The name of the active user.
- @: Separates the user name from the host name.
- host: The name of the system or machine.
- :: Separates the host name from the path.
- path: The current directory the user is in.
- $ or #: The final character indicating the permission level:
- **$** for normal users.
- **#** for the superuser (root).

## Important Directories in Linux

The file system in Linux follows a hierarchical structure with a single root represented by **/**. From this root, the different directories of the system are organized.
```
/
├── boot/ - Files needed for system boot (kernel, GRUB, etc.).
├── etc/ - System and application configuration files.
├── var/ - Variable data files (logs, databases, print queues, etc.).
│ ├── log/ - System log files.
│ ├── spool/ - Print and mail queues.
│ └── tmp/ - Persistent temporary files.
├── usr/ - Files shared by users and applications.
│ ├── bin/ - Common application executables.
│ └── lib/ - Shared libraries.
├── home/ - User home directories.
├── root/ - Home directory of the system administrator (root).
├── tmp/ - Temporary files that are deleted after a reboot.
├── dev/ - Special files that represent hardware devices.
├── sbin/ - Essential executables for system administration and recovery.
├── proc/ - Virtual file system with information about processes and system state.
├── sys/ - Virtual file system that represents the system hardware.
├── opt/ - Additional or third-party software.
├── mnt/ - Temporary mount points for file systems.
├── media/ - Mount points for removable devices such as USB drives or CD/DVDs.
└── lib/ - Essential shared libraries for **/bin/** and **/sbin/**.
```
## Important Files in Linux
The file system not only organizes directories, but also contains specific files with class roles for proper system operation and configuration.
```
/
├── etc/
│   ├── passwd            - Information about system users.
│   ├── group             - Information about system groups.
│   ├── shadow            - User passwords stored in encrypted form.
│   ├── fstab             - File system mount configuration. (Usually edited manually)
│   ├── network/
│   │   └── interfaces      - Network interface configuration (older distributions).
│   ├── hostname          - System hostname. (Usually edited manually)
│   ├── resolv.conf       - DNS server configuration. (Usually edited manually)
│   └── crontab           - System scheduled task configuration.
├── var/
│   ├── log/
│   │   ├── syslog            - Main system log.
│   │   ├── auth.log          - Authentication and access logs.
│   │   └── dmesg             - Kernel logs during boot.
│   └── spool/
│       └── cron/             - Scheduled tasks pending execution.
├── boot/
│   └── grub/
│       └── grub.cfg          - GRUB bootloader configuration.
├── proc/
│   ├── cpuinfo           - Information about the system's CPU.
│   ├── cmdline           - Contains all the information passed to the kernel during startup.
│   ├── meminfo           - Information about the system's memory.
│   ├── modules           - Contains a list of currently loaded modules.
│   └── uptime            - System uptime.
├── home/
│   └── nom_user/
│       ├── .bashrc           - Bash shell configuration for a user.
│       └── .ssh/
│           ├── id_rsa            - User's private SSH key.
│           └── authorized_keys   - Public keys authorized for SSH connection.
├── root/
│   └── .bashrc           - Bash shell configuration for the root user.
├── usr/
│   ├── bin/
│   │   └── top               - Executable of the `top` command for monitoring.
│   └── share/
│       └── man/              - System manual pages.
├── dev/
    ├── null              - Special device to discard data.
    ├── sda               - Main hard drive (block device).
    └── tty               - Terminal devices.
```

## Environment Variables in Linux
These are dynamic values ​​that influence how processes execute within the system. These variables allow applications to obtain information about the environment or set default configurations for their execution. They can be queried, defined, and manipulated using specific commands:
- Display environment variables:
- **env**: Displays all available environment variables.
- **echo $VARIABLE_NAME**: Displays the value of a specific variable.
- Define a new local variable
- **Variable=directory path:$Variable**: Adds a new path to the selected variable.
- Define a new environment variable:
- **export VARIABLE_NAME=value**: Creates or modifies an environment variable in the current session.
- Delete an environment variable:
- **unset VARIABLE_NAME**: Deletes the specified environment variable.
Important Environment Variables:
- **PATH**: Defines the paths where the system will search for executables when running commands.
- **HOME**: Specifies the current user's home directory.
- **USER**: Contains the name of the logged-in user.
- **SHELL**: Indicates the shell being used during the session.
- **TERM**: Defines the type of terminal being used, useful for adjusting settings for terminal-based applications.
- **EDITOR**: Sets the default text editor for programs like crontab or git.
- **LANG**: Specifies the system's language and locale settings.

## Absolute and Relative Paths
Paths are used to locate files and directories within the file system. These are divided into absolute paths and relative paths:
1. **Absolute Paths**:
- These represent the location of a file or directory relative to the system root (**/**).
- They always begin with the **/** character.
- They are independent of the directory the user is in.
2. **Relative Paths**:
- They indicate the location of a file or directory relative to the current working directory.
- They never begin with the **/** character.
- They depend on the directory the user is working in.
3. **Special Characters in Navigation**:
- . (Period):
- Represents the current directory.
- It is used to refer to the directory the user is currently in.
- When a file or directory begins with a (.), it is considered hidden.
- .. (Period Period):
- Represents the parent directory, in other words, the directory immediately above the current one.

## Understanding Standards
Data input and output between programs, commands, and users is managed by three main streams, known as **Stdin**, **Stdout**, and **Stderr**. These standards are essential for efficient interprocess communication and user interaction.
- **Stdin or Standard input**: This is the standard stream used to receive data that a program needs to process. By default, it is associated with the keyboard, although it can be redirected from other sources, such as a file or the output of another command. It is represented by the number 0 in the system.
- **Stdout or Standard output**: This is the standard stream where a program sends the results of its execution. By default, it is associated with the terminal emulator, but it can be redirected to files or to the standard input of another program. It is represented by the number 1 in the system.
- **Stderr or Standard error**: This is the standard stream used for error or diagnostic messages generated by a program. By default, it is also associated with the terminal emulator, although it can be redirected to a separate file or combined with standard output. It is represented by the number 2 in the system.

## What is a file descriptor?
It is a numeric identifier used by the system to represent input and output resources, such as files, devices, or data streams. In UNIX and Linux systems, each running process has three file descriptors open by default:
- **0 (Stdin)**: Standard input.
- **1 (Stdout)**: Standard output.
- **2 (Stderr)**: Standard error output.
Among its main functions are:
- They allow programs to interact with external resources in an efficient and unified manner.
- Identifiers can be manipulated to redirect input and output to different destinations, such as files, devices, or even other processes.
Uses in command control:
- **Debugging programs**: Separates normal output from errors to facilitate problem identification.
- **Automation**: Makes it possible to store data for later analysis or send information to other processes.
- **Flexibility**: Using commands like grep, awk, or sed. File descriptors enhance advanced data processing.

## Redirections in Linux
These are tools that allow you to control the input and output flow of commands, sending or capturing data to files or between commands.
**Redirection Operators**:
1. *(>) Overwrite standard output*: Redirects the standard output of a command to a file, overwriting the existing contents.
2. *(>>) Append to file*: Adds standard output to the end of the file.
3. *( | ) Pipe*: Allows you to chain multiple commands, passing the standard output of one command as standard input to the next.

## Differences between arguments and parameters
Commands can be customized or configured using parameters and arguments. Although they are often used interchangeably, they have specific roles:
1. **Parameters**:
- These are options or flags that modify the behavior of a command.
- They are generally specified with:
- Single hyphen (-): Followed by a letter.
- Double hyphen (--): Followed by a complete word.
- They allow you to activate additional functions or change how the command is executed.
2. **Arguments**:
- These are values ​​or data that a command needs to perform a specific action.
- They indicate the elements on which the command should act.
- They often appear after parameters.
3. **Key Differences**:
- Parameters alter the behavior of the command.
- Arguments specify what data the command should act on.

## Logical Operators
- **&&** (AND): Allows a second command to be executed only if the first one executes successfully.
- **||** (OR): Allows a second command to be executed only if the first one fails.
- **!** (NOT): Reverses the result of a command execution.
- **;** (Sequence): Allows you to execute multiple commands sequentially, regardless of whether the previous ones succeed or fail.

## Glob Characters
They are a feature of the shell, not specific to any specific command. As a result, they can be used with any existing command in Linux.
- **Asterisk ( * )**: Matches zero or more characters in a file or directory name.
- **Question mark (?)**: Matches exactly one character in a file name.
- **Square brackets ( [ ] )**: Matches any character within the specified set.
- **Single quotes ( ' )**: Prevent the shell from interpreting all special characters. "Protects" a string from being modified by the shell.
- **Double quotes ( " )**: Allow variable expansion and command substitution, but protect other special characters such as spaces or globs.
- **Backtick (`` ` ``)**: Allows command substitution, executing the command within the shell and replacing it with its output.
- **Forward slash ( \ )**: Escapes a special character to treat it literally rather than interpreting it.
## Basic Regular Expressions
This is a collection of "normal" and "special" characters used to match a simple or complex pattern. The basic regular expressions are as follows:

| Regular Expression | Matches |
| ---------------------- | -------------------------------------------------------------- |
| Period ( . ) | Any single character. |
| Square brackets ( [ ] ) | A list or range of characters that match a character. |
| Asterisk ( * ) | The previous character, repeated zero or more times |
| Caret (^) | The following text must appear at the beginning of the line. |
| Dollar ( $ ) | The previous text must appear at the end of the line |

## Linux Commands
The syntax for commands in Linux is: **[Command (Options) (Arguments)]**
Options: Options can be used to modify the behavior of a command.
Arguments: An argument can be used to specify something the command should act upon.

### Information and Help
- **man**: This is the first line of help for understanding how other commands work.
*-k*: Displays a summary of all manual pages for the assigned keyword.
*-f*: Displays pages matching the specified name.
- **info**: This is similar to the man command, but with a different format, as it sometimes provides more detailed information than man.
- **whatis**: Provides a fairly brief description of the command to look up.
- **apropos**: Helps find commands related to a keyword.
- **whereis**: Searches for commands, source code files, and man pages in the specified locations where these files are stored.
- **which**: Displays the path to the executable file associated with a command.
- **type**: This is used to determine information about multiple commands; it can also identify built-in commands in bash or another shell. It can also identify aliases for other commands.
*-a*: Reveals the path to another command.
*-t*: Indicates the type of command (executable, function, alias, etc.)
- **help**: Provides information only on commands built into the shell being used.
- **alias**: Allows you to view aliases defined in the shell.

### Search for files or directories
- **find**: Searches for files in the file system, either by name or even wildcard characters if the exact name is unknown. Additionally, it can search for files based on file metadata, such as file type, file size, and file ownership. Its parameters include:
*-name*: Searches for a file by name.
*-ls*: Displays file details.
*-size ( +/- Size to search )*: Allows you to search for files by size.
*-iname*: Searches by file name, but is not case-sensitive.
*-user*: Returns files owned by a specific user.
- **grep**: Filters lines in a file or the output of another command based on a pattern match. This can be done using exact text or regular expressions. There are several parameters:
*-i*: Makes the search case-insensitive.
*-c*: Counts the number of lines containing the search pattern.
*-n*: Displays the original line numbers.
- **locate**: Primarily used to find the location of files within the system. To update the "locate" database, use sudo updatedb.
### To navigate in the terminal
- **cd**: Stands for Change Directory and changes the current directory. It accepts both relative and absolute paths.
*Double period (..)*: Represents the directory above the current directory.
*Period (.)*: Used to refer to the current directory.
- **pwd**: Print Working Directory stands for Print Working Directory, which basically prints the current working directory.
- **ls**: List stands for List, and its function is to list directories and files. It has important parameters such as:
*-a*: Displays all files, including hidden files.
*-l*: Displays everything in a longer format.
*-R*: Enters each directory and lists its contents.
*-h*: Displays details, but in human-readable sizes, such as KB, MB, or GB.
*-d*: Refers to the current directory, not its contents.
*-S*: Sorts files by size.
*-t*: Displays files by when they were modified.
- **history**: Stores a history of executed commands. A command can be used from the history with an exclamation mark (**!**) and the number of where the desired command is located.
### File Management
- **touch**: Its main function is to create empty files.
- **cp**: It is the acronym for copy and allows copying both files and directories, its syntax is: cp (source) (destination). Its parameters are:
    *-i*: Asks for confirmation before copying a file.
    *-r*: Works to copy directories recursively.
    *-v*: Reproduces the command output.
- **mv**: It is the acronym for move and works to move and rename files and directories, its syntax is: mv (source) (destination). Its parameters are:
    *-i*: Asks for confirmation before moving a file.
    *-u*: Only overwrites the file if the destination file is older.
- **rm**: It is the acronym for remove and works to delete files and directories, its syntax is: rm (asset to be deleted). Its parameters are:
    *-i*: Asks for confirmation before deleting a file.
    *-r*: Works to delete directories recursively.

### File Viewing
- **cat**: It is the acronym for concatenate, it originated to concatenate and display the content of files, but currently it is rarely used for that purpose, as it is mainly used to read (not very large) files within the terminal, its syntax is: cat (file path). Its parameter is:
    *-n*: Works to number the lines while reading a file.
- **head**: Shows the first 10 lines of a file, the difference with "cat" is that it would show the entire file. With the parameter
    *-n*: You can indicate the number of lines you want to read.
- **tail**: Shows the file, but starting from the last 10 lines. With the parameter
    *-n*: You can indicate the number of lines you want to read.
    *-f*: Allows you to follow the content of a file in real time.
- **less**: Shows the content of a file in a paginated way, in other words, it allows you to view the file page by page. Its parameters are:
    *-n*: Shows the line number when viewing a file.
    *-f*: Follows the content of the file in real time.
- **sort**: It is a command used to sort lines of text in a file, either alphabetically or numerically, and also supports sorting based on specific columns. It is especially useful for processing and organizing large amounts of data. Parameters that can be used:
    *-f*: Ignores case sensitivity when sorting.
    *-o*: Works to save the result in a file.
    *-n*: For numerical sorting.
    *-t*: To sort them separated by a specific field.
    *-c*: Verifies if the file is already sorted.
    *-k*: An argument is indicated to specify the number of fields.
    *-r*: Performs a reverse sort.

### Directory Management
- **mkdir**: It is the acronym for make directory and its basic function is to create directories within the file system, its syntax is mkdir (directory path). Its parameter is:
    *-p*: Works to create parent directories.
- **rmdir**: Its meaning is remove directory and it only works to delete directories that are empty. Its parameter is:
    *-r*: Deletes non-empty directories.
- **ln**: Allows creating hard links to a file or directory. Among its parameters is:
    *-s*: Allows creating symbolic links.

### User Management
- **adduser**: It is a command used to create new users on the system.
- **deluser**: It is a command used to delete a user from the system. Its most common parameter is:
    *–remove-home*: Allows you to delete the user and also the home directory assigned to that user.
- **usermod**: Allows you to modify user properties such as the username, home directory, or the group to which it is assigned. Its main parameters are:
    *-l ­*: Allows you to change the user's login name.
    *-d*: Allows you to change the user's home directory.
    *-L*: Locks the user's account.
    *-U*: Unlocks the user's account.
- **passwd**: Used to change a user's password. Allows certain parameters:
    *-l*: Locks the user's password.
    *-u*: Unlocks the user's password.
- **id**: It is the acronym for identification and allows you to identify the information of the current user or the user indicated. Its parameters are:
    *-u*: Only shows the user's UID (user ID).
    *-g*: Shows the user's GID (user group).
- **who**: Allows you to know who is connected to the system. Allows several parameters such as:
    *-u*: Shows connected users along with the connection time.
- **w**: Provides a more detailed list of users currently on the system.
- **su:** It is the acronym for switch user and allows you to change users, if a username is not specified, it will always try to switch to the root user. It has a series of parameters such as:
    *-l* or *–-login*: Provides an environment similar to what the user would have if they logged in.
    *-c*: Allows you to execute a command as the indicated user without having to log in as that user.
- **sudo**: Allows you to execute commands with another user's privileges. It has several parameters such as:
    *-u*: Allows you to specify the user with whom you want to execute the command.
    *-i*: Provides an environment similar to what the user would have if they logged in.
    *-s*: Tells the command to provide a shell of the indicated user.
- **whoami**: Provides the username associated with the current user ID in the terminal.
- **finger**: Provides information about a particular user.

### Group Management
- **groupadd**: Allows you to create groups within the system, it is necessary to run it by the root user. Among its parameters are:
    *-g*: Used to specify an ID for the new group.
- **groupdel**: Allows you to delete groups, if the group has a user inside, you must first remove them.
- **groupmod**: Allows you to modify the name of a group, it has several parameters:
    *-n*: Allows you to change the group name.
    *-g*: Allows you to change the GID of the group.
    *-aG*: Used to add a user to a group.
    *-G*: Sets the supplementary group of the user.
- **gpasswd**: Used to manage group passwords and members of each group. It has several parameters such as:
    *-a*: With which you can add a user to a group.
    *-d*: With which you can delete a user from a group.
- **groups**: Allows you to see the groups to which a user belongs.
- **newgrp**: Allows you to change the primary group to which the user belongs.

### Network Management
In Linux, 2 types of nomenclature are used: traditional names (not persistent and not very descriptive) and predictive names (persistent and descriptive, based on the physical location or hardware topology of the NIC).
- **ifconfig**: Lists all active network interfaces showing details such as IP address, mask, packet statistics, among others. Among its parameters are:
    *up*: To turn on a network interface.
    *down*: To turn off a network interface.
- **ip**: It is a tool that displays and manipulates routes, devices, routing policies, and tunnels. Among its parameters are:
    *a* or *addr*: Shows all network interfaces with their IP addresses.
- **ip route**: Shows the kernel's routing table, basically the routing table through which packets travel. Among its parameters are:
    *add* + *via*: Used to add a new route.
- **netstat**: Allows you to view routing tables, interface statistics, masquerade connections, multicast members. It has several parameters:
    *-t*: Shows TCP connections.
    *-u*: Shows UDP connections.
    *-l*: Shows only listening ports.
    *-p*: Shows the PID.
    *-e*: Shows extended information.
    *-i*: Shows network traffic statistics.
    *-r*: Shows routing information.
    *-n*: Shows the number, not the service name.
- **ping**: Allows you to verify connectivity with other hosts. It has several parameters:
    *-c*: Specifies the number of packets you want to send.
- **traceroute**: Shows the path that packets take to reach a destination host. Its parameters are:
    *-m*: Specifies the number of hops before the command stops tracing.
- **nslookup**: Allows you to perform queries to the DNS server. There are several parameters:
    *-type*: Used to specify the type of record you want to search for.
- **hostname**: Works to display and configure the operating system name.
- **nc**: Stands for netcat, it is a tool mainly used to open and close ports. It has several parameters such as:
    *-l*: Allows you to listen on a port.
    *-v*: Activates verbose mode to show more details.
    *-p*: You can indicate a port with it.
    *-n*: So that it does not perform DNS resolution.
    *-u*: To use the UDP protocol instead of TCP, which is the default.
- **dig**: Tests the functionality of the DNS server of the host being used; for this, it performs queries on the DNS server to determine if the necessary information is available.

### DEB Package Management
- **apt**: Comes natively in Debian-based distributions, so it will not be found natively in other distros. It is the acronym for advanced packaging tool. It simplifies the installation, updating, and removal of packages, as it automatically resolves the dependencies necessary to install a package. For its correct operation, it is necessary to run the command with sudo permissions. It has several parameters:
    *update*: Updates the list of available packages and their versions.
    *upgrade*: Installs the latest versions of the packages installed on the system.
    *full-upgrade*: Performs a complete upgrade.
    *install*: Performs package installation.
    *remove*: Removes packages installed on the system.
    *autoremove*: Removes packages that were installed as dependencies and are no longer needed.
    *--purge remove*: Removes all files of a software package, including configuration files.
- **apt-get**: It is an older version of **apt** but it is more stable and shares its same parameters; there are others such as:
    *dist-upgrade*: In addition to performing the functions of the upgrade parameter, it is also capable of intelligently managing changes in dependencies with new package-level versions.
- **apt-cache**: Performs searches and obtains information about the packages stored in the apt cache. For its correct operation, it is necessary to run the command with sudo permissions. Some of its parameters are:
    *depends*: Shows the dependencies of the mentioned package.
    *policy*: Shows the installed policy of the mentioned package, including the versions and from which repository the package will be installed.
    *search*: Searches the system repositories for the mentioned package.
- **dpkg:** It is the acronym for Debian package, basically it is the low-level management system in Debian-based distros, which only manages specific **.deb** packages. Its parameters are:
    *-i*: To install.
    *-l*: Shows a list of the packages installed on the system.
    *-r*: Used to remove a package; but it is not a complete removal since it deletes the package but keeps its configuration files on the system.
    *-p*: Completely removes the package.
    *-L*: Lists the files that make up a specific package.
- **dpkg-query**: Used to perform queries on the dpkg database.
- **dpkg-reconfigure**: Used to reconfigure a package after it has been installed.
- **dpkg-trigger**: Allows you to activate events in the package system.

### RPM Package Management
- **rpm**: It is the low-level package management system for Red Hat packages. It performs its queries by connecting to a local database on the machine. Among its parameters are:
    *-qa*: Shows a list of all packages currently installed on the system.
    *-ql*: Lists the files that make up a specific package.
    *-qi*: Queries a package and obtains information or its status.
- **yum**: Automates the process of resolving dependency issues; if you want to add, update, or remove packages, you need root permissions. Among its parameters are:
    *search*: Searches for packages from the configured repositories.
    *install*: Installs packages along with their dependencies.
    *update*: Updates all packages.
    *remove*: Removes a package, resolving dependency issues.

### Web Package Management
- **wget**: Allows you to download files from the internet, supporting the main protocols HTTP, HTTPS, or FTP. Its parameters are:
    *-c*: Allows you to continue an interrupted download.
    *--no-check-certificate*: Ignores TLS certificate verification.
- **curl**: Works to transfer data to or from a server using various protocols and is mainly used for API testing or simply downloading files or sending data. Among its parameters are:
    *-X*: You can specify the HTTP request method.
    *-H*: You can add headers to the request.

### Compressed File Management
- **tar**: Allows you to create compressed files. It has several parameters:
    *-c*: Indicates the creation of a file.
    *-z*: Uses gzip to compress.
    *-v*: Shows the processed files.
    *-f*: Specifies the output file name.
    *-x*: Indicates file extraction.
    *-t*: Lists the documents in the packaged archive.
    *-j*: Decompresses with bzip2 before reading.
- **gzip**: It is a command that allows you to compress individual files to which the .gz extension is added. It has the following parameters:
    *-d*: You can decompress files.
    *-l*: Shows information about the compression.
- **zip**: Allows you to compress files, but with the .zip extension.
- **unzip**: Allows you to decompress .zip files.

### Process Management
Each process in Linux consists of several key points. Each process has a PID (Process Identifier) which is unique for each process. In turn, there are also types of processes, such as: user processes, which are processes initiated and controlled by users, and system processes, which are processes initiated and managed by the operating system and are necessary for its operation. Processes have an assigned state, whether running, sleeping, stopped, or zombie.
- **ps**: Shows information about active processes. It has parameters such as:
    *a*: Shows the processes of all users.
    *u*: Shows detailed user information.
    *x*: Includes processes that do not have an associated terminal.
    *aux* or *-ef*: Shows all system processes.
- **pstree**: Shows processes in a family tree format, showing parents and children.
- **top**: Shows all running processes and their resource consumption in real time.
- **free**: Shows the amount of memory used at the moment.
- **kill**: Used to send signals to a process and is commonly used to terminate the process. The following signals are used for this command.
- **killall**: Terminates all processes associated with the given name.
- **free**: Shows the system's memory status, including physical and swap memory. Its parameter is:
    *-b*: Shows the information in bits.
- **fg**: It is the acronym for ForeGround, it allows you to bring a background process to the foreground.
- **bg**: It is the acronym for BackGround, it wakes up a suspended process but runs it in the background.
- **jobs**: Allows you to see suspended or background processes.
- **disown**: Removes the entire list of jobs and consequently can detach from a process that has already been created from the terminal and leave it independently in the system.

### For Owner and Permission Management
- **chown**: Allows you to change the owner and group of a file or directory, it must be used by the root user. A parameter that can be used is:
    *-R*: Applies the changes to a complete directory structure.
- **chgrp**: It is the acronym for Change Group, it only allows you to change the group to which a file or directory will belong, it must be used by the root user. A parameter that can be used is:
    *-R*: Applies the changes to a complete directory structure.
- **stat:** Shows detailed information about the permissions and ownership of directories.
- **chmod**: This command allows you to modify the permissions of both directories and files and other system assets, and allows you to do this both octally and symbolically. A parameter that can be used is:
    *-R*: Applies permissions recursively at the directory level.

### Additional Commands
- **echo**: Allows you to print different types of values on the screen. Its parameters are:
    *-n*: Does not print the new line at the end of the text.
    *-e*: Enables the interpretation of escape sequences such as \n (newline) and \t (tab).
- **du**: Allows you to show the space used by files and directories on disk. The parameter can be used:
    *-a*: Shows the usage of all files.
## File Editors from the Terminal

### Vim/NVim
It is an improved version of the "vi" editor, which is one of the most used editors in the Linux community. To open a file with vim, you would use the command `vim` followed by the file path, and if the file does not exist, one will be created with the assigned path. It offers multiple modes such as:

#### Normal Mode
Default mode when a file is opened. You can use keys and commands to navigate the file and perform actions such as deleting text, copying and pasting, etc. However, keep in mind that in this mode, you cannot insert text directly. Useful keys for normal mode:
1. **Basic Navigation**:
	- h: move left.
	- j: move down.
	- k: move up.
	- l: move right.
2. **Advanced Navigation**:
	- w: jump to the beginning of the next word.
	- e: jump to the end of the current word.
	- b: move back to the beginning of the previous word.
3. **Text Manipulation**:
	- dd: delete a line.
	- yy: copy a line.
	- p: paste what has been copied or deleted.
	- u: undo the last action.
	- Ctrl + r: Redo the last undone action.

#### Insert Mode
Allows adding text to the file. To enter this mode from normal mode, you must:
- Press **i** to insert text before the cursor.
- Press **a** to insert text after the cursor.
- Press **o** to insert a new line below the cursor.
To exit this mode, press **Esc**.

#### Command Mode
To access this mode, press **:** (colon). Here you can execute advanced commands to save, exit, search, and perform other operations.
1. **Save and Exit**:
	- :w : Save changes.
	- :q : Exit (only if there are no pending changes).
	- :q! : Exit without saving.
	- :wq o \:x : Save and exit.
2. **Search**:
	- :/palabra: Search for "palabra" forwards.
	- :?palabra: Search for "palabra" backwards.
	- n: Jump to the next result.
	- N: Jump to the previous result.

### Nano
Nano is a text editor like vim but much simpler to use. It is mainly used from the terminal and is ideal for quickly editing files without a complex learning curve.

#### Common Options When Opening Nano
When using nano, you can use certain parameters to modify its behavior. Among which are:
La sintaxis es: [nano (parámetro) nomb\_archivo]
- -m: El uso del ratón para interactuar con el texto.
- -l: Activa la visualización del número de líneas del archivo.
- -v: Abre el archivo en modo lectura, evitando las modificaciones accidentales.
- -B: Crea una copia de seguridad del archivo antes de guardar los cambios.
- -E: Elimina espacios en blanco innecesarios al final de las líneas.
- -i: Agrega sangría automáticamente al comienzo de nuevas líneas.

## Atajos en Linux

#### De línea de comandos
- **Ctrl+a**: Permite moverse al inicio de la línea.
- **Ctrl+e**: Permite moverse al final de la línea.
- **Ctrl+b**: Mueve el cursor un carácter hacia atrás.
- **Ctrl+f**: Mueve el cursor un carácter hacia adelante.
- **Alt+b**: Mueve el cursor una palabra hacia atrás.
- **Alt+f**: Mueve el cursor una palabra hacia adelante.
- **Ctrl+xx**: Alterna entre el inicio de la línea y la posición actual del cursor.

#### De procesos
- **Ctrl+c**: Termina el proceso actual.
- **Ctrl+z**: Suspende el proceso actual.
- **Ctrl+d**: Permite salir de la terminal si no hay texto

#### De historiales de comandos
- **Ctrl+p**: Con él se puede navegar hacia el comando anterior en el historial.
- **Ctrl+n**: Sirve para navegar al siguiente comando en el historial.
- **Ctrl+r**: Con él se puede buscar dentro del historial
- **Ctrl+o**: Dentro del historial de comandos se puede ejecutar el comando en cuestión. Es un complemento de **Ctrl+r**.

#### Del emulador de terminal
- **Ctrl+l**: Se limpia la terminal.
- **Ctrl+s**: Se detiene el desplazamiento de salida de la terminal.
- **Ctrl+q**: Reanuda el desplazamiento.
- **Ctrl+ Alt + (F1-F6)**: Permite cambiar entre las terminales TTI

## Alias en Linux
Es una forma de darle una palabra clave a una instrucción personalizada, en otras palabras, funcionan para poder ejecutar un comando con ciertos parámetros y argumentos, pero hacer solamente a través de una palabra clave. Con el comando **alias** se muestran los comandos que se hayan utilizado, para crear un alias se utiliza **alias (nombre del alias = comando)**. Hay que tener en cuenta que los alias son temporales, si se reinicia o se apaga el sistema los alias creados se eliminan, para hacerlos permanentes hay que añadirlos al fichero .bashrc. Para eliminar un alias se utiliza **unalias + nombre del alias**.

## Tipos de archivos
Los tipos de archivos se pueden identificar en el primer campo a la hora de enlistar los archivos con el comando **ls** con el parámetro **-l**.
Los tipos de archivos son:

| Símbolo |  Tipo de archivo   |                                  Descripción                                   |
| :-----: | :----------------: | :----------------------------------------------------------------------------: |
|    d    |     Directorio     |                 Un archivo usado para contener otros archivos.                 |
|    -    | Archivo ordinario  | Incluye archivos leíbles, imágenes, archivos binarios, y archivos comprimidos. |
|    l    | Enlaces simbólicos |                             Apunta a otro archivo.                             |
|    s    |       Socket       |                    Permite la comunicación entre procesos.                     |
|    p    |   Tubería (pipe)   |                    Permite la comunicación entre procesos.                     |
|    b    |   Archivo bloque   |             Usado para comunicaciones con el equipo (_hardware_).              |
|    c    |  Archivo carácter  |             Usado para comunicaciones con el equipo (_hardware_).              |

## Permisos
Existen varios tipos de permisos que se le pueden asignar tanto a los ficheros como a los directorios,  los cuales son los permisos de lectura o **r**ead, escritura o **w**rite y ejecución o e**x**ecute. A nivel de asignación de permisos se puede realizar de 2 maneras, ya sea asignación octal o simbólica.

#### Asignación octal de permisos
Cada tipo de permiso tiene un valor numérico:
- r = 4, w = 2, x = 1
Se asignan combinando los valores para cada categoría de usuarios:
- Propietario (u): Usuario que creó el archivo/directorio.
- Grupo (g): Usuarios que pertenecen al grupo del archivo/directorio.
- Otros (o): Todos los demás usuarios.
*Ejemplo*:
chmod 754 nomb\_archivo
- **7 (propietario)**: r + w + x = 4 + 2 + 1 = 7
- **5 (grupo)**: r + x = 4 + 1 = 5
- **4 (otros)**: r = 4

#### Asignación simbólica de permisos
Se utiliza letras para definir permisos y operadores para asignarlos:
1. Permisos:
	- r = lectura, w = escritura, x = ejecución.
2. Categorías:
	- u = propietario, g = grupo, o = otros, a = todos.
3. Operadores:
	- +(agrega), - (remueve), = (establecer exacto)
*Ejemplos*:
chmod g+w nomb\_archivo -> Agrega permisos de escritura al grupo.
chmod g-w nomb\_archivo -> Remueve permisos de escritura al grupo.

## Otros permisos

#### SUID O Set User ID
- **Función**:
	- Permite ejecutar un archivo como si fuera el propietarios, sin importar quién lo ejecute.
	- Únicamente se puede asignar a archivos ejecutables.
- **Símbolo**: (s) reemplaza la (x) en los permisos del grupo.
- **Octal**: Se representa con un **4** *Ejemplo*: chmod **4**755 nomb\_archivo

#### SGID o Set Group ID
- **Función**:
	- En archivos: Se ejecutan como si pertenecieran al grupo del archivo.
	- En directorios: Los archivos creados heredan el grupo del directorio.
- **Símbolo**: (s) reemplaza la (x) en los permisos del propietario.
- **Octal**: Se representa con un **2** *Ejemplo*: chmod **2**755 nomb\_archivo

#### Stickt Bit
- **Función**:
	- Restringe la manipulación de archivos en directorios compartidos, permitiendo solo al propietario o el administrador pueda eliminarlos o modificarlos.
	- Únicamente es aplicable a directorios.
- **Símbolo**: (t) en los permisos de otros.
- **Octal**: Se representa con un **1** *Ejemplo*: chmod **1**755 nomb\_archivo.

### Resumen de permisos
|      Permiso       | Octal | Símbolo |
| :----------------: | :---: | :-----: |
|    Lectura (r)     |   4   |    r    |
|   Escritura (w)    |   2   |    w    |
|   Ejecución (x)    |   1   |    x    |
| SUID (propietario) |   4   |    s    |
|    SGID (grupo)    |   2   |    s    |
| Sticky Bit (otros) |   1   |    t    |
